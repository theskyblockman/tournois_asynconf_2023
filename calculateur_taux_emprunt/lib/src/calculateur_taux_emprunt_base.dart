typedef PointData = ({double pointsAmount, int maxPoints});
typedef InputData = Map<int, dynamic>;
typedef OutputData = ({
  PointData outData,
  int ignoredPoints,
});

class RateRule {
  /// Only called when meetsRequirement is [true].
  ///
  /// Returns The [pointsAmount] out of [maxPoints] to be added to the global rating.
  final PointData Function(InputData data) calculateRate;
  /// Should [calculateRate] be called.
  final bool Function(InputData data) meetsRequirements;

  const RateRule({required this.calculateRate, required this.meetsRequirements});
}

class BorrowingRateCalculator {
  /// The global rating, generated by user-inputted data
  OutputData calculateRate(InputData data) {
    int ignoredPoints = 0;
    final points = rules
        .where((rule) {
          if (rule.meetsRequirements(data)) {
            return true;
          } else {
            ignoredPoints++;
            return false;
          }
        })
        .map((rule) => rule.calculateRate(data))
        .reduce((value, element) => (
              pointsAmount: value.pointsAmount + element.pointsAmount,
              maxPoints: value.maxPoints + element.maxPoints
            ));
    return (
      outData: points,
      ignoredPoints: ignoredPoints,
    );
  }

  /// The set of "rules" who does all the different ratings.
  final List<RateRule> rules;

  const BorrowingRateCalculator({required this.rules});
}
